import { HttpClient, HttpParams } from "@angular/common/http";
import { Component, Inject, OnInit, ViewChild } from "@angular/core";
import { MatDialogRef, MAT_DIALOG_DATA } from "@angular/material/dialog";
import { MatPaginator } from "@angular/material/paginator";
import { MatSnackBar } from "@angular/material/snack-bar";
import { MatTableDataSource } from "@angular/material/table";
import { NgxSpinnerService } from "ngx-spinner";
import { Subject } from "rxjs";
import { takeUntil } from "rxjs/operators";
import { AuthenticationService, UserProfile } from "src/app/services/authentication.service";
import { ConfirmDialogService } from "src/app/services/confirm-dialog.service";
import { environment } from "src/environments/environment";
@Component({
  selector: "weakness-link-vulnerability-dialog",
  templateUrl: "weakness-link-vulnerability-dialog.html",
  styleUrls: ["weakness-link-vulnerability-dialog.css"]
})
export class WeaknessLinkVulnerabilityDialog implements OnInit {
  @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator;
  displayedColumns: string[] = ['no', 'component', 'swhw', 'cveid', 'publishDate', 'description', 'baseScore', 'treatment', 'reviewed', 'validated', 'linkToWeakness'];
  dataSource: MatTableDataSource<any> = new MatTableDataSource<any>([]);
  readonly newDesign = JSON.parse(localStorage.getItem("newDesign"));
  currentUserProfile: UserProfile
  private unsubscribe: Subject<void> = new Subject();
  vulnerabilitiesUrl = `${environment.backendApiUrl}vulnerability/${this.newDesign.project.id}`
  changedItems: any = [];
  generatedVulnerability: boolean = false;
  vulnerability = {}
  confirmToCancel = {
    title: "CONFIRMATION",
    message: "Are you sure you want to discard all of your linking changes?",
    cancelText: "No",
    confirmText: "Yes",
    color:"primary"
  };
  disableGenerate: boolean = false;

  constructor(private http: HttpClient, private _authService: AuthenticationService,
    private _spinner: NgxSpinnerService, private _snackBar: MatSnackBar,
    @Inject(MAT_DIALOG_DATA) public data: any, 
    public dialogRef: MatDialogRef<WeaknessLinkVulnerabilityDialog>,private _confirmDialogService: ConfirmDialogService
  ) { }
  /*fetch vulnerabilities from backend, convert it to FE model and update data source
    if user is coming from notification component, scroll to that specific vulnerability and highlight it for 8 seconds
  */
  ngOnInit(): void {
    this.getProjectVulnerabilities()
  }

  getProjectVulnerabilities() {
    this._spinner.show("vulnerability-spinner");
    let params = new HttpParams().set('id',this.newDesign.project.id);
    this.http.get(this.vulnerabilitiesUrl,{params}).pipe(takeUntil(this.unsubscribe))
      .subscribe((data: any[]) => {
        this.dataSource.data = data
        this.dataSource.data.forEach((item, index) => {
          item.no = index + 1;
          item.swhw = `${item?.sbom?.product ?? ''}${item?.sbom?.product && item?.hbom?.product ? '/' : ''}${item?.hbom?.product ?? ''}`;
          item.publishedDate === null ? item.publishedDate = "" : item.publishedDate = new Date(item.publishedDate);
          item.initialLinks = item.linkedWeaknesses ?? [];
          if (item.linkedWeaknesses.includes(this.data.weakness._id)) {
            item.linked = true;
          } else {
            item.linked = false;
          }
          const checkDate = item.publishedDate instanceof Date && !isNaN(item.publishedDate.valueOf())
          if (!checkDate) {// If date is an invalid date set it to string
            item.publishedDate = "";
          }
        });
        this._spinner.hide("vulnerability-spinner");
      },
        (error) => this._spinner.hide("vulnerability-spinner"),
        () => this._spinner.hide("vulnerability-spinner")
      )
  }

  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;

  }

  ngOnDestroy() {
    this.unsubscribe.next();
    this.unsubscribe.complete();
  }

  /*Track by treatment index-value*/
  trackByTreatment(index: number, value: any) {
    return `treatment-${index}-${value}`;
  }

  /*converts boolean value of reviewed and validated to yes and no to show on checkboxes*/
  convertBoolToYesNo(rowBooleanVals) {
    return rowBooleanVals ? 'Yes' : 'No'
  }

  /*checkbox is ticked add the vulnerability to the list of changedItems
    to send to the backend only the vulnerabilities which are actually linked or unlinked
  */
  linkedChanged($event, row) {
    const i = this.dataSource.data.findIndex(item => item._id == row._id);
    const alreadyExists = this.changedItems.indexOf(this.dataSource.data[i])
    if ($event.checked) {
      this.dataSource.data[i].linkedWeaknesses.push(this.data.weakness._id);
    } else if (!$event.checked) {
      const index = this.dataSource.data[i].linkedWeaknesses.indexOf(this.data.weakness._id);
      this.dataSource.data[i].linkedWeaknesses.splice(index, 1);
    }
    if (alreadyExists > -1) {
      this.changedItems[alreadyExists] = this.dataSource.data[i];
    } else {
      this.changedItems.push(this.dataSource.data[i]);
    }
  }

  postData() {
    const vulnerabilities = this.changedItems.map(function (row) {
      return { _id: row._id, linkedWeaknesses: row.linkedWeaknesses }
    });
    const linkedVulnerabilities = [];
    this.dataSource.data.map(item => {
      if (item.linkedWeaknesses.includes(this.data.weakness._id) && item?._id) {
        linkedVulnerabilities.push(item._id)
      }
    })
    const weaknessData = { _id: this.data.weakness._id, linkedVulnerabilities }
    const data = { vulnerabilities, linkWeakness: true, weaknessData,generated:null, projectId:this.newDesign.project.id };
    if(this.generatedVulnerability){
      data.generated = this.vulnerability;
    }
    this.dialogRef.close(data)
  }

  generateVulnerability() {
    if (this.generatedVulnerability) {
      this.generatedVulnerability = false;
      this.vulnerability = {};
      this.dataSource.data.pop();
    } else {
      this.generatedVulnerability = true;
      const weakness = this.data.weakness;
      const vulnerability = {
        no: this.dataSource.data.length + 1,
        component: weakness.component,
        cveDataMetaIds: "",
        sbom:{product:weakness.attackSurface},
        swhw:weakness.attackSurface,
        description: weakness.exploitableRationale,
        reviewed: false,
        treatment: "no treatment",
        baseScore: 0,
        baseSeverity: "NONE",
        publishedDate: new Date(),
        vulnerabilitySource: "weakness",
        validated: false,
        linkedWeaknesses: [weakness._id],
        linked:true,
        isNotified:true,
        projectId:this.newDesign.project.id,
        gen:true
      }
      this.dataSource.data.push(vulnerability);
      this.vulnerability = vulnerability;
    }
    this.updateDataSource();
  }

  updateDataSource() {
    this.dataSource.data = [...this.dataSource.data];
  }

  closeDialog(){
    this._confirmDialogService.open(this.confirmToCancel);
    this._confirmDialogService.confirmed().subscribe((confirmed) => {
      if (confirmed) {
        this.dialogRef.close();
      }
    })
  }
}