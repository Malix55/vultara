import { Injectable } from '@angular/core';
import * as moment from 'moment';
import { ThreatItem } from 'src/threatmodel/ItemDefinition';

@Injectable({
  providedIn: 'root'
})
export class ReportsService {

  constructor() { }

  // Process CSV data for cover sheet
  getCoverSheetData(projectName: string, userName: string) {
    return [
      ["Threat Analysis and Risk Assessment Report", ""],
      ["", ""],
      ["Project", projectName],
      ["Report Generated By", userName],
      ["Report Generated Date", moment(Date.now()).format("YYYY/MM/DD")],
      ["", ""],
      ["Confidential", ""],
      ["", ""],
      ["Powered by VULTARA"],
    ]
  }

  // Process CSV data for assumptions column
  getAssumptionData(assumptions: any[]) {
    return assumptions.map((assumption: any) => {
      let assumptionProperties: any = new Object();
      assumptionProperties["Assumptions"] = assumption.content;
      return assumptionProperties;
    });
  }

  // Process CSV data for vulnerabilities
  getVulnerabilityData(vulnerabilities: any[]) {
    return vulnerabilities.map((vulnerability: any) => {
      let tableSelectedProperties = new Object();
      tableSelectedProperties["Component"] = vulnerability.component;
      tableSelectedProperties["sw/hw"] = `${vulnerability?.sbom?.product ?? ''}${vulnerability?.sbom?.product && vulnerability?.hbom?.product ? '/' : ''}${vulnerability?.hbom?.product ?? ''}`;
      tableSelectedProperties["CVE ID"] = vulnerability.cveDataMetaIds;
      tableSelectedProperties["Published Date"] = vulnerability.publishedDate;
      tableSelectedProperties["Description"] = vulnerability.description;
      tableSelectedProperties["Base Score"] = vulnerability.baseScore + ' ' + vulnerability.baseSeverity;
      tableSelectedProperties["Treatment"] = vulnerability.treatment;
      tableSelectedProperties["Treatment Val"] = vulnerability.treatmentVal;
      tableSelectedProperties["Validated"] = vulnerability.validated;
      tableSelectedProperties["Reviewed"] = vulnerability.reviewed;
      tableSelectedProperties["Vulnerability Source"] = vulnerability.vulnerabilitySource;
      return tableSelectedProperties;
    });
  }

  // Process CSV data for threats
  getThreatListData(mergedTable: ThreatItem[]) {
    return mergedTable.map((threat: ThreatItem) => {
      let tableSelectedProperties = {};
      tableSelectedProperties["Asset"] = threat.asset;
      tableSelectedProperties["Security Property"] = threat.securityPropertyCia;
      tableSelectedProperties["Feature"] = threat.fromFeature;
      tableSelectedProperties["Module"] = threat.module;
      tableSelectedProperties["Threat Scenario"] = threat.threatScenario;
      tableSelectedProperties["Attack Path"] = threat.attackPathName;
      tableSelectedProperties["Damage Scenario"] = threat.damageScenario;
      tableSelectedProperties["Attack Feasibility"] = threat.attackFeasibilityLevel;
      tableSelectedProperties["Attack Feasibility - Elapsed Time"] = threat.attackFeasibilityElapsed;
      tableSelectedProperties["Attack Feasibility - Expertise"] = threat.attackFeasibilityExpertise;
      tableSelectedProperties["Attack Feasibility - Knowledge"] = threat.attackFeasibilityKnowledge;
      tableSelectedProperties["Attack Feasibility - Window of Opportunity"] = threat.attackFeasibilityWindow;
      tableSelectedProperties["Attack Feasibility - Equipment"] = threat.attackFeasibilityEquipment;
      tableSelectedProperties["Impact - Safety"] = threat.impactSLevel;
      tableSelectedProperties["Impact - Financial"] = threat.impactFLevel;
      tableSelectedProperties["Impact - Operational"] = threat.impactOLevel;
      tableSelectedProperties["Impact - Privacy"] = threat.impactPLevel;
      // attack feasibility parameters not configurable in report
      if (threat.treatment == "no treatment") {
        tableSelectedProperties["Risk"] = threat.riskLevel;
      } else {
        tableSelectedProperties["Risk"] = threat.riskLevelBefore;
        tableSelectedProperties["Attack Feasibility After"] = threat.attackFeasibilityLevelAfter;
        tableSelectedProperties["Attack Feasibility After - Elapsed Time"] = threat.attackFeasibilityElapsedAfter;
        tableSelectedProperties["Attack Feasibility After - Expertise"] = threat.attackFeasibilityExpertiseAfter;
        tableSelectedProperties["Attack Feasibility After - Knowledge"] = threat.attackFeasibilityKnowledgeAfter;
        tableSelectedProperties["Attack Feasibility After - Window of Opportunity"] = threat.attackFeasibilityWindowAfter;
        tableSelectedProperties["Attack Feasibility After - Equipment"] = threat.attackFeasibilityEquipmentAfter;
        tableSelectedProperties["Impact After - Safety"] = threat.impactSLevelAfter;
        tableSelectedProperties["Impact After - Financial"] = threat.impactFLevelAfter;
        tableSelectedProperties["Impact After - Operational"] = threat.impactOLevelAfter;
        tableSelectedProperties["Impact After - Privacy"] = threat.impactPLevelAfter;
        tableSelectedProperties["Risk After Treatment"] = threat.riskLevel;
      }
      tableSelectedProperties["Last Modified By"] = threat.lastModifiedBy;
      tableSelectedProperties["Reviewed"] = threat.reviewed;
      tableSelectedProperties["Reviewed By"] = threat.reviewedBy;
      tableSelectedProperties["Treatment"] = threat.treatment;
      tableSelectedProperties["Treatment Validated"] = threat.treatmentVal;
      tableSelectedProperties["Treatment Validated By"] = threat.treatmentValidatedBy;
      tableSelectedProperties["Cybersecurity Claim"] = threat.cybersecurityClaim;
      tableSelectedProperties["Notes"] = threat.notes;
      return tableSelectedProperties
    });
  }

  // Download a report from the external URL.
  public downloadTaraReportFromBrowser(url: string) {
    let reportLinkHTMLElement = document.createElement("a");
    reportLinkHTMLElement.href = url;
    reportLinkHTMLElement.setAttribute("download", "TARA Report.docx");
    // start download
    reportLinkHTMLElement.click();
  }
}
